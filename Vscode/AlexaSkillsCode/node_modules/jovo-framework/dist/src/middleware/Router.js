"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const jovo_core_1 = require("jovo-core");
const _get = require("lodash.get");
const _merge = require("lodash.merge");
const _set = require("lodash.set");
class Router {
    constructor(config) {
        this.config = {
            intentMap: {},
            intentsToSkipUnhandled: [],
        };
        if (config) {
            this.config = _merge(this.config, config);
        }
    }
    static intentRoute(handlers, state, intent, intentsToSkipUnhandled) {
        let _state = state + ''; // tslint:disable-line:variable-name
        const _intent = intent + ''; // tslint:disable-line:variable-name
        let path = state ? state + '.' + intent : intent;
        // rewrite path if there is a dot in the intent name
        if (_intent && _intent.indexOf('.') > -1) {
            path = state ? state : '';
            path += '["' + _intent + '"]';
        }
        if (_get(handlers, path)) {
            return {
                intent,
                path,
                state,
                type: jovo_core_1.EnumRequestType.INTENT,
            };
        }
        if (_state) {
            while (_state !== '') {
                if (_get(handlers, _state + '["' + _intent + '"]')) {
                    path = _state + '["' + _intent + '"]';
                    return {
                        intent,
                        path,
                        state,
                        type: jovo_core_1.EnumRequestType.INTENT,
                    };
                }
                // State 'unhandled' is available and intent is not in intentsToSkipUnhandled
                if (_get(handlers, _state + '.' + jovo_core_1.EnumRequestType.UNHANDLED)) {
                    if (!intentsToSkipUnhandled || intentsToSkipUnhandled.indexOf(_intent) === -1) {
                        path = _state + '.' + jovo_core_1.EnumRequestType.UNHANDLED;
                        return {
                            intent,
                            path,
                            state,
                            type: jovo_core_1.EnumRequestType.INTENT,
                        };
                    }
                }
                _state = Router.getLastLevel(_state);
            }
            // is intent in global?
            if (_get(handlers, _intent)) {
                return {
                    intent,
                    path: _intent,
                    state,
                    type: jovo_core_1.EnumRequestType.INTENT,
                };
            }
        }
        const pathToUnhandled = _state
            ? _state + '.' + jovo_core_1.EnumRequestType.UNHANDLED
            : jovo_core_1.EnumRequestType.UNHANDLED;
        if (_get(handlers, pathToUnhandled)) {
            path = pathToUnhandled;
        }
        return {
            intent,
            path,
            state,
            type: jovo_core_1.EnumRequestType.INTENT,
        };
    }
    /**
     * Returns last level of path
     * @param {string} route
     * @return {string}
     */
    static getLastLevel(route) {
        let level = '';
        if (route.indexOf('.')) {
            level = route.substr(0, route.lastIndexOf('.'));
        }
        return level;
    }
    /**
     * Maps given intent by the platform with a map in the config
     * Uses component's intent map if it's active
     *
     * @param {Config} appConfig
     * @param {string} intentName
     * @param {string} component
     * @returns {string}
     */
    static mapIntentName(appConfig, intentName, component) {
        // use component's intent map if component is in use:
        if (component) {
            const componentIntentMap = component.config.intentMap;
            if (componentIntentMap && componentIntentMap[intentName]) {
                jovo_core_1.Log.verbose(`Mapping intent from ${intentName} to ${componentIntentMap[intentName]}`);
                return componentIntentMap[intentName];
            }
        }
        // use intent mapping if set
        if (appConfig.intentMap && appConfig.intentMap[intentName]) {
            jovo_core_1.Log.verbose(`Mapping intent from ${intentName} to ${appConfig.intentMap[intentName]}`);
            return appConfig.intentMap[intentName];
        }
        return intentName;
    }
    install(app) {
        app.middleware('router').use(this.router.bind(this));
    }
    async router(handleRequest) {
        jovo_core_1.Log.white().verbose(jovo_core_1.Log.header('Jovo router ', 'framework'));
        if (!handleRequest.jovo) {
            return;
        }
        if (!handleRequest.jovo.$type || !handleRequest.jovo.$type.type) {
            throw new Error(`Couldn't access request type`);
        }
        let route = {
            path: handleRequest.jovo.$type.type,
            type: handleRequest.jovo.$type.type,
        };
        if (handleRequest.jovo.$type.type && handleRequest.jovo.$type.subType) {
            route.path = `${handleRequest.jovo.$type.type}["${handleRequest.jovo.$type.subType}"]`;
        }
        if (route.type === jovo_core_1.EnumRequestType.INTENT) {
            // do intent stuff
            if (!handleRequest.jovo.$nlu || !handleRequest.jovo.$nlu.intent) {
                throw new Error(`Couldn't get route for intent request.`);
            }
            // parse component to `mapIntentName` only if it's active
            let activeComponent;
            const componentSessionStack = handleRequest.jovo.$session.$data[jovo_core_1.SessionConstants.COMPONENT];
            if (componentSessionStack && componentSessionStack.length > 0) {
                const latestComponentFromSessionStack = componentSessionStack[componentSessionStack.length - 1];
                activeComponent = handleRequest.jovo.$components[latestComponentFromSessionStack[0]];
            }
            const intent = Router.mapIntentName(this.config, handleRequest.jovo.$nlu.intent.name, activeComponent);
            route = Router.intentRoute(handleRequest.jovo.$handlers, handleRequest.jovo.getState(), intent, handleRequest.jovo.$app.config.intentsToSkipUnhandled);
        }
        else if (route.type === jovo_core_1.EnumRequestType.END) {
            route = Router.intentRoute(handleRequest.jovo.$handlers, handleRequest.jovo.getState(), jovo_core_1.EnumRequestType.END, handleRequest.jovo.$app.config.intentsToSkipUnhandled);
            route.type = jovo_core_1.EnumRequestType.END;
        }
        else if (route.type === jovo_core_1.EnumRequestType.AUDIOPLAYER) {
            route.path = `${jovo_core_1.EnumRequestType.AUDIOPLAYER}["${handleRequest.jovo.$type.subType}"]`;
        }
        else if (route.type === jovo_core_1.EnumRequestType.ON_ELEMENT_SELECTED) {
            // workaround
            route = Router.intentRoute(handleRequest.jovo.$handlers, handleRequest.jovo.getState(), jovo_core_1.EnumRequestType.ON_ELEMENT_SELECTED, handleRequest.jovo.$app.config.intentsToSkipUnhandled);
            route.type = jovo_core_1.EnumRequestType.ON_ELEMENT_SELECTED;
            if (typeof _get(handleRequest.jovo.$handlers, route.path) === 'object') {
                route.path += '.' + handleRequest.jovo.$type.subType;
            }
        }
        _set(handleRequest.jovo.$plugins, 'Router.route', route);
        jovo_core_1.Log.yellow().verbose('Route object:');
        jovo_core_1.Log.yellow().verbose(`${JSON.stringify(route, null, '\t')}`);
    }
}
exports.Router = Router;
//# sourceMappingURL=Router.js.map